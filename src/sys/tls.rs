/* automatically generated by rust-bindgen */

pub const TLS_TX: u32 = 1;
pub const TLS_RX: u32 = 2;
pub const TLS_1_2_VERSION_MAJOR: u32 = 3;
pub const TLS_1_2_VERSION_MINOR: u32 = 3;
pub const TLS_CIPHER_AES_GCM_128: u32 = 51;
pub const TLS_CIPHER_AES_GCM_128_IV_SIZE: u32 = 8;
pub const TLS_CIPHER_AES_GCM_128_KEY_SIZE: u32 = 16;
pub const TLS_CIPHER_AES_GCM_128_SALT_SIZE: u32 = 4;
pub const TLS_CIPHER_AES_GCM_128_TAG_SIZE: u32 = 16;
pub const TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE: u32 = 8;
pub const TLS_SET_RECORD_TYPE: u32 = 1;
pub const TLS_GET_RECORD_TYPE: u32 = 2;
pub type __u16 = libc::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_crypto_info {
    pub version: __u16,
    pub cipher_type: __u16,
}
#[test]
fn bindgen_test_layout_tls_crypto_info() {
    assert_eq!(
        ::core::mem::size_of::<tls_crypto_info>(),
        4usize,
        concat!("Size of: ", stringify!(tls_crypto_info))
    );
    assert_eq!(
        ::core::mem::align_of::<tls_crypto_info>(),
        2usize,
        concat!("Alignment of ", stringify!(tls_crypto_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tls_crypto_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_crypto_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tls_crypto_info>())).cipher_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tls_crypto_info),
            "::",
            stringify!(cipher_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_aes_gcm_128 {
    pub info: tls_crypto_info,
    pub iv: [libc::c_uchar; 8usize],
    pub key: [libc::c_uchar; 16usize],
    pub salt: [libc::c_uchar; 4usize],
    pub rec_seq: [libc::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_tls12_crypto_info_aes_gcm_128() {
    assert_eq!(
        ::core::mem::size_of::<tls12_crypto_info_aes_gcm_128>(),
        40usize,
        concat!("Size of: ", stringify!(tls12_crypto_info_aes_gcm_128))
    );
    assert_eq!(
        ::core::mem::align_of::<tls12_crypto_info_aes_gcm_128>(),
        2usize,
        concat!("Alignment of ", stringify!(tls12_crypto_info_aes_gcm_128))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tls12_crypto_info_aes_gcm_128>())).info as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tls12_crypto_info_aes_gcm_128),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tls12_crypto_info_aes_gcm_128>())).iv as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tls12_crypto_info_aes_gcm_128),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tls12_crypto_info_aes_gcm_128>())).key as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tls12_crypto_info_aes_gcm_128),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tls12_crypto_info_aes_gcm_128>())).salt as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tls12_crypto_info_aes_gcm_128),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<tls12_crypto_info_aes_gcm_128>())).rec_seq as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tls12_crypto_info_aes_gcm_128),
            "::",
            stringify!(rec_seq)
        )
    );
}
